== 배열과 구조체 사이의 형변환

=== 학습목표
* 바이트 배열을 구조체로 형변환해서 사용하는 방법을 안다.
* 슬랙 바이트와 Pack이 필요한 이유를 설명할 수 있다.

=== 내용
구조체도 배열의 일종이에요. 
배열은 크기가 같은 변수가 메모리상에서 2개 이상 붙어있는 형태이고,
구조체는 크기에 상관없이 변수가 메모리상에서 1개 이상 붙어있는 형태에요.




=== 슬랙 바이트

슬랙은 영어로 느슨하다는 뜻입니다. 슬랙 바이트는 느슨한 바이트라는 뜻이죠. 이게 무슨 말인고 하니, 컴퓨터 속도와 관련되어 있습니다.

더 자세하게 말하면, 64 bit 컴퓨터는 메모리를 64 bit 단위로 한번에 처리하는게 가장 빠릅니다.

계산하기 쉽게 64 bit는 8 byte로 바꿔 말할께요.

구조체를 하나 선언하고 내부에 4byte 크기의 int형 변수를 2개 집어넣고 8byte 크기의 long long형 변수를 집어넣으면 합이 16byte로 정확히 8의 배수가 됩니다.
이 상태를 ``정렬된 상태``라고 합니다.


.64bit 컴퓨터
[source,c++]
----
struct AlignedStruct
{
    char a[8];    // 8 byte
    int b;        // 4 byte 
    int c;        //        + 4 byte = 8byte
    long long d;  // 8 byte
}; // 구조체 크기 = 24 byte
----


속도가 빨라지는 것은 좋은데, 매번 이렇게 8 byte에 맞춰 정렬된 상태로 변수를 선언하자니 너무나도 정신력이 소모되는 일이 아닐 수 없습니다.

다행스럽게도 우리 똑똑한 컴파일러는 메모리를 조금 더 많이 사용해서 자동으로 정렬된 상태를 만들어줍니다.
여기서 ``정렬``을 위해 메모리가 더 사용된 영역이 바로 ``슬랙 바이트``라고 하는 영역입니다.

.64bit 컴퓨터
[source,c++]
----
struct UnalignedStruct
{
    char a[6];       // 6 + 슬랙 바이트 2 = 8 byte
    int b;           // 4 + 슬랙 바이트 4 = 8 byte
    long long c;     // 8 + 슬랙 바이트 0 = 8 byte
}; // 구조체 크기 = 24 byte
----

구조체의 맨 위에서부터 변수의 크기를 계산해서 다음 변수와 합이 8 byte을 초과하면 슬랙 바이트를 만들고 0부터 다시 계산합니다.

그래서 변수를 선언하는 순서에 따라서 구조체의 크기가 달라질 수 있습니다.

UnalignedStruct 구조체를 정렬시키기 위해서 컴파일러는 총 6 byte를 더 사용했습니다.

이러한 과정들은 마치 텍스트 편집기에서 자동 줄나눔 옵션을 설정했을 때와 매우 유사합니다.
